using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using Sharpbot.Database;
using Sharpbot.Providers;

namespace Sharpbot.Agent;

/// <summary>A single search result from semantic memory.</summary>
public sealed record SemanticSearchResult(
    int Id,
    string Content,
    string Source,
    string? SourceId,
    float Score,
    DateTime CreatedAt);

/// <summary>
/// Semantic memory engine using SQLite BLOB storage and C# cosine similarity.
/// Stores text chunks as embeddings generated by the LLM provider's embedding API.
/// For personal-assistant scale (hundreds to low-thousands of memories), brute-force
/// cosine similarity is instant (&lt;50ms for 10K vectors).
/// </summary>
public sealed class SemanticMemoryStore
{
    private const int MaxChunkChars = 2000;  // ~500 tokens
    private const int ChunkOverlapChars = 200;

    private readonly SharpbotDb _db;
    private readonly ILlmProvider _provider;
    private readonly string _embeddingModel;
    private readonly ILogger? _logger;

    public SemanticMemoryStore(
        SharpbotDb db,
        ILlmProvider provider,
        string embeddingModel = "text-embedding-3-small",
        ILogger? logger = null)
    {
        _db = db;
        _provider = provider;
        _embeddingModel = embeddingModel;
        _logger = logger;
    }

    /// <summary>
    /// Index a piece of content into semantic memory.
    /// Text is chunked by paragraphs (or fixed-size windows), embedded, and stored.
    /// </summary>
    public async Task IndexAsync(
        string content,
        string source = "manual",
        string? sourceId = null,
        string? metadataJson = null,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(content)) return;

        var chunks = ChunkText(content);
        _logger?.LogInformation("Indexing {ChunkCount} chunk(s) from source={Source}, sourceId={SourceId}",
            chunks.Count, source, sourceId);

        var now = DateTime.UtcNow.ToString("o");

        foreach (var chunk in chunks)
        {
            try
            {
                var embedding = await _provider.EmbedAsync(chunk, _embeddingModel, ct);
                var embeddingBlob = FloatsToBytes(embedding);

                using var conn = _db.CreateConnection();
                using var cmd = conn.CreateCommand();
                cmd.CommandText = """
                    INSERT INTO memory_embeddings (content, embedding, dimensions, source, source_id, metadata_json, created_at, updated_at)
                    VALUES (@content, @embedding, @dimensions, @source, @sourceId, @metadata, @created, @updated)
                    """;
                cmd.Parameters.AddWithValue("@content", chunk);
                cmd.Parameters.AddWithValue("@embedding", embeddingBlob);
                cmd.Parameters.AddWithValue("@dimensions", embedding.Length);
                cmd.Parameters.AddWithValue("@source", source);
                cmd.Parameters.AddWithValue("@sourceId", (object?)sourceId ?? DBNull.Value);
                cmd.Parameters.AddWithValue("@metadata", (object?)metadataJson ?? DBNull.Value);
                cmd.Parameters.AddWithValue("@created", now);
                cmd.Parameters.AddWithValue("@updated", now);
                cmd.ExecuteNonQuery();
            }
            catch (Exception ex)
            {
                _logger?.LogWarning(ex, "Failed to index chunk ({Length} chars) from {Source}", chunk.Length, source);
            }
        }
    }

    /// <summary>
    /// Search semantic memory for the most relevant chunks matching the query.
    /// </summary>
    public async Task<List<SemanticSearchResult>> SearchAsync(
        string query,
        int topK = 5,
        float minScore = 0.7f,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(query)) return [];

        float[] queryEmbedding;
        try
        {
            queryEmbedding = await _provider.EmbedAsync(query, _embeddingModel, ct);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to embed query for semantic search");
            return [];
        }

        // Load all embeddings from the database
        var candidates = new List<(int Id, string Content, string Source, string? SourceId, float[] Embedding, DateTime CreatedAt)>();

        using (var conn = _db.CreateConnection())
        using (var cmd = conn.CreateCommand())
        {
            cmd.CommandText = "SELECT id, content, embedding, dimensions, source, source_id, created_at FROM memory_embeddings";
            using var reader = cmd.ExecuteReader();
            while (reader.Read())
            {
                var id = reader.GetInt32(0);
                var content = reader.GetString(1);
                var blob = (byte[])reader[2];
                var dims = reader.GetInt32(3);
                var source = reader.GetString(4);
                var sourceId = reader.IsDBNull(5) ? null : reader.GetString(5);
                var createdAt = DateTime.Parse(reader.GetString(6));

                var embedding = BytesToFloats(blob, dims);
                candidates.Add((id, content, source, sourceId, embedding, createdAt));
            }
        }

        if (candidates.Count == 0) return [];

        // Compute cosine similarity for all candidates
        var scored = new List<SemanticSearchResult>();
        foreach (var (id, content, source, sourceId, embedding, createdAt) in candidates)
        {
            if (embedding.Length != queryEmbedding.Length) continue;
            var score = CosineSimilarity(queryEmbedding.AsSpan(), embedding.AsSpan());
            if (score >= minScore)
                scored.Add(new SemanticSearchResult(id, content, source, sourceId, score, createdAt));
        }

        return scored
            .OrderByDescending(r => r.Score)
            .Take(topK)
            .ToList();
    }

    /// <summary>Delete all embeddings from a specific source (and optional source ID).</summary>
    public void DeleteBySource(string source, string? sourceId = null)
    {
        using var conn = _db.CreateConnection();
        using var cmd = conn.CreateCommand();

        if (sourceId != null)
        {
            cmd.CommandText = "DELETE FROM memory_embeddings WHERE source = @source AND source_id = @sourceId";
            cmd.Parameters.AddWithValue("@source", source);
            cmd.Parameters.AddWithValue("@sourceId", sourceId);
        }
        else
        {
            cmd.CommandText = "DELETE FROM memory_embeddings WHERE source = @source";
            cmd.Parameters.AddWithValue("@source", source);
        }

        var deleted = cmd.ExecuteNonQuery();
        _logger?.LogInformation("Deleted {Count} embedding(s) from source={Source}, sourceId={SourceId}",
            deleted, source, sourceId);
    }

    /// <summary>Get stats about the semantic memory store.</summary>
    public SemanticMemoryStats GetStats()
    {
        using var conn = _db.CreateConnection();
        using var cmd = conn.CreateCommand();
        cmd.CommandText = """
            SELECT
                COUNT(*) as total,
                COALESCE(MAX(dimensions), 0) as dimensions,
                COUNT(DISTINCT source) as sources
            FROM memory_embeddings
            """;
        using var reader = cmd.ExecuteReader();
        reader.Read();
        return new SemanticMemoryStats(
            TotalChunks: reader.GetInt32(0),
            Dimensions: reader.GetInt32(1),
            DistinctSources: reader.GetInt32(2));
    }

    /// <summary>
    /// Split text into chunks by paragraphs. If a paragraph exceeds the max size,
    /// split further at sentence boundaries. Applies overlap between chunks.
    /// </summary>
    internal static List<string> ChunkText(string text)
    {
        var chunks = new List<string>();
        if (string.IsNullOrWhiteSpace(text)) return chunks;

        // Split by double-newline (paragraphs)
        var paragraphs = text.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries);

        var currentChunk = new StringBuilder();
        foreach (var para in paragraphs)
        {
            var trimmed = para.Trim();
            if (trimmed.Length == 0) continue;

            // If adding this paragraph would exceed the limit, flush current chunk
            if (currentChunk.Length > 0 && currentChunk.Length + trimmed.Length + 2 > MaxChunkChars)
            {
                chunks.Add(currentChunk.ToString().Trim());
                // Keep overlap from end of previous chunk
                var overlapText = GetOverlapText(currentChunk.ToString(), ChunkOverlapChars);
                currentChunk.Clear();
                if (!string.IsNullOrEmpty(overlapText))
                    currentChunk.Append(overlapText).Append(' ');
            }

            // If a single paragraph is too large, split at sentence boundaries
            if (trimmed.Length > MaxChunkChars)
            {
                if (currentChunk.Length > 0)
                {
                    chunks.Add(currentChunk.ToString().Trim());
                    currentChunk.Clear();
                }

                var sentences = SplitSentences(trimmed);
                var sentenceChunk = new StringBuilder();
                foreach (var sentence in sentences)
                {
                    if (sentenceChunk.Length + sentence.Length + 1 > MaxChunkChars && sentenceChunk.Length > 0)
                    {
                        chunks.Add(sentenceChunk.ToString().Trim());
                        var overlap = GetOverlapText(sentenceChunk.ToString(), ChunkOverlapChars);
                        sentenceChunk.Clear();
                        if (!string.IsNullOrEmpty(overlap))
                            sentenceChunk.Append(overlap).Append(' ');
                    }
                    sentenceChunk.Append(sentence).Append(' ');
                }
                if (sentenceChunk.Length > 0)
                    currentChunk.Append(sentenceChunk);
            }
            else
            {
                if (currentChunk.Length > 0)
                    currentChunk.Append("\n\n");
                currentChunk.Append(trimmed);
            }
        }

        if (currentChunk.Length > 0)
            chunks.Add(currentChunk.ToString().Trim());

        return chunks.Where(c => c.Length > 0).ToList();
    }

    private static string GetOverlapText(string text, int maxChars)
    {
        if (text.Length <= maxChars) return text;
        return text[^maxChars..];
    }

    private static List<string> SplitSentences(string text)
    {
        var sentences = new List<string>();
        var current = new StringBuilder();

        foreach (var ch in text)
        {
            current.Append(ch);
            if (ch is '.' or '!' or '?' && current.Length > 10)
            {
                sentences.Add(current.ToString().Trim());
                current.Clear();
            }
        }

        if (current.Length > 0)
            sentences.Add(current.ToString().Trim());

        return sentences;
    }

    /// <summary>Compute cosine similarity between two float vectors.</summary>
    internal static float CosineSimilarity(ReadOnlySpan<float> a, ReadOnlySpan<float> b)
    {
        float dot = 0, normA = 0, normB = 0;
        for (int i = 0; i < a.Length; i++)
        {
            dot += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }

        var denom = MathF.Sqrt(normA) * MathF.Sqrt(normB);
        return denom == 0 ? 0 : dot / denom;
    }

    /// <summary>Serialize a float array to a byte array (zero-copy via MemoryMarshal).</summary>
    private static byte[] FloatsToBytes(float[] floats)
    {
        var bytes = new byte[floats.Length * sizeof(float)];
        MemoryMarshal.AsBytes(floats.AsSpan()).CopyTo(bytes);
        return bytes;
    }

    /// <summary>Deserialize a byte array back to a float array.</summary>
    private static float[] BytesToFloats(byte[] bytes, int dimensions)
    {
        var floats = new float[dimensions];
        MemoryMarshal.Cast<byte, float>(bytes.AsSpan()).CopyTo(floats);
        return floats;
    }
}

/// <summary>Statistics about the semantic memory store.</summary>
public sealed record SemanticMemoryStats(int TotalChunks, int Dimensions, int DistinctSources);

/// <summary>Utilities for embedding model resolution.</summary>
public static class EmbeddingModelResolver
{
    /// <summary>
    /// Auto-detect the correct embedding model based on the chat model provider.
    /// Gemini uses text-embedding-004, OpenAI uses text-embedding-3-small, etc.
    /// </summary>
    public static string Resolve(string configuredModel, string chatModel)
    {
        // If the user explicitly set a non-default embedding model, honor it
        if (configuredModel != "text-embedding-3-small")
            return configuredModel;

        // Auto-detect based on the chat model's provider
        var chatModelLower = chatModel.ToLowerInvariant();
        if (chatModelLower.Contains("gemini"))
            return "gemini-embedding-001";

        return configuredModel;
    }
}
